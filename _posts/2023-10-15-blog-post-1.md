---
title: 'How to combine RADEX and MCMC'
date: 2023-10-16
permalink: /posts/2023/10/RADEX+MCMC/
tags:
  - calculation
  - codes
  - MCMC
---

[RADEX](https://personal.sron.nl/~vdtak/radex/index.shtml) ([van der Tak et al. 2007](https://ui.adsabs.harvard.edu/abs/2007A%26A...468..627V/abstract)) is a simple but powerful code to solve non-LTE radiative transfer, and has been widely used in various astronomical environments. Generally, we use this code to fit the physical parameters of a molecular cloud with multiple transitions of a single molecular species. When fitting the data, we tend to minimize a loss function (or something similar), and MCMC (Markov chain Monte Carlo) is a powerful method to get the global minimum (instead of local minimum, which is the drawback of other methods like [scipy.optimize.curve_fit](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve%5Ffit.html) whose fitting results strongly depend on the initial values given by the user) and a robust estimation of the error. <br>

I am a heavy user of RADEX, but know little about MCMC. However, it seems that we can still run a basic MCMC fitting code without a rich knowledge about how MCMC works. It is never a bad choice, though, to know more about MCMC before you start using it. This blog mainly refers to [the basic tutorial of emcee](https://emcee.readthedocs.io/en/stable/tutorials/line/), the [radex_emcee](https://github.com/yangcht/radex_emcee) code written by Chentao Yang, and *my private conversation with my roomate*. I do not guarantee that everything in this blog is correct. 

## Prerequisites
The following codes are run in Jupyter Notebook. Other packages you may need are: 
* [emcee](https://emcee.readthedocs.io/en/stable/) to run MCMC and [corner](https://corner.readthedocs.io/en/latest/) to make corner plots.
* a python interface of RADEX. I choose [spectralradex](https://spectralradex.readthedocs.io/en/latest/) (Note that you must not use [pandas](https://pandas.pydata.org/)>2.0 with spectralradex. See [this issue](https://github.com/uclchem/SpectralRadex/issues/9) for details.), and [myRadex](https://github.com/fjdu/myRadex) is also a good choice. You can also write a simple script to run RADEX in python. <br>
 
We first import all the packaged we will use in the code:
```python
import numpy as np
import matplotlib.pyplot as plt
from spectralradex import radex
from multiprocessing import Pool
import time
import emcee 
import corner
from random import uniform
```

## Try Spectralradex
We hereafter use the [Podio et al. (2014)](https://ui.adsabs.harvard.edu/abs/2014A%26A...565A..64P/abstract) as the observation. The authors observed multiple HCO<sup>+</sup> transitions in the prototypical protostellar shock L1157-B1. The integrated intensity is $7.4\pm 0.01\ \text{K km/s}$ for the 1-0 line, $5.49\pm 0.09$ for the 3-2 line, $0.38\pm 0.03$ for the 6-5 line, and $0.14\pm 0.03$ for the 7-6 line. Their LVG model gives $T_{\text{kin}} \sim 60\ \text{K}$, $n_{\text{H}_2} \sim 10^5\ \text{cm}^{-3}$ and $N(\text{HCO}^+)\sim 6\times 10^{12}\ \text{cm}^{-2}$. <br>

We need to first try to run spectralradex to find the location of our target transitions. The input physical parameters are rather arbitraty: 
```python
radex_params_hcop = {
        'molfile': 'hco+.dat',
        'tkin': 30,
        'tbg': 2.73,
        'cdmol': 1e14,
        'h2': 1e5,
        'h': 0.0,
        'e-': 0.0,
        'p-h2': 0.0,
        'o-h2': 0.0,
        'h+': 0.0,
        'linewidth': 5,
        'fmin': 0.0,
        'fmax': 900.0,
        'geometry': 2}
```
Then we can run spectralradex and display the resulting DataFrame simply with:
```
df_hcop = radex.run(radex_params_hcop)
df_hcop
```
The target transitions are in the 0th, 2nd, 5th and 6th rows. Note that you can also use a variable named ```Jlow``` to make your code more flexible, but you still need more consideration when fitting transitions like NH<sub>3</sub>. 


## The likelihood function
We need to define a lilelihood function which we want to maximize with MCMC. It is a Gaussian centered at the observed flux of the molecular transition with a sigma of the obvervation uncertainty:
$$\ln p = -\frac{1}{2} \sum_n \left[ \frac{ (\text{model}-\text{obs})^2 }{ \text{sigma}^2 }  + \ln \text{sigma}^2 \right]$$
where $n$ is the number of your observed transitions. Note that we use the logarithm of the likelihood function $p$. Maximizing this function means that the closer for the modelled values to the observed values, the better. <br>

Then we can define the likelihood function in our code: 
```python
def log_likelihood(theta, transition, flux, err_flux):
    log_T, log_n, log_N = theta 
    T = 10.0**log_T
    N = 10.0**log_N
    n = 10.0**log_n
    
    radex_params_hcop = {
        'molfile': 'hco+.dat',
        'tkin': T,
        'tbg': 2.73,
        'cdmol': N,
        'h2': n,
        'h': 0.0,
        'e-': 0.0,
        'p-h2': 0.0,
        'o-h2': 0.0,
        'h+': 0.0,
        'linewidth': 5,
        'fmin': 0.0,
        'fmax': 900.0,
        'geometry': 2}
    
    df_hcop = radex.run(radex_params_hcop)
    flux10 = df_hcop.iloc[0]['FLUX (K*km/s)']
    flux32 = df_hcop.iloc[2]['FLUX (K*km/s)']
    flux65 = df_hcop.iloc[5]['FLUX (K*km/s)']
    flux76 = df_hcop.iloc[6]['FLUX (K*km/s)']
    
    model = np.array([flux10, flux32, flux65, flux76])
    return -0.5 * np.sum( (flux-model)**2.0 / err_flux**2.0 + np.log(err_flux**2.0) )
```
Note that we use the logarithm of the input parameters because it is more convenient in most cases. Next, we need to define a prior function of the physical parameters. It's a little bit elusive for newcomers of MCMC, but the form of the function is simple - a uniform prior is enough for our analysis: 
```python
def log_prior(theta):
    log_T, log_n, log_N = theta 
    bool1 = np.log10(5.0)<log_T<3.0
    bool2 = 1.0<log_n<7.0
    bool3 = 10.0<log_N<16.0
    if bool1 and bool2 and bool3:
        return 0.0
    return -np.inf
```
In this function, we set a bounding box for the physical parameters. It means that if $5\ \text{K}< T <10^3\ \text{K}$, $10^1\ \text{cm}^{-3} < n_{\text{H}_2} < 10^7\ \text{cm}^{-3}$ and $10^{10} \ \text{cm}^{-2} < N < 10^{16} \ \text{cm}^{-2}$, the prior function will return a finite value. Otherwise it will return an infinite value. You can also define a variable array ```bounds``` to describe these ranges and to make your code more flexible. <br>
Then, combining this with the definition of log_likelihood from above, the full log-probability function is:
```python
def log_probability(theta, transition, flux, err_flux):
    lp = log_prior(theta)
    if not np.isfinite(lp):
        return -np.inf
    return lp + log_likelihood(theta, transition, flux, err_flux)
```
This is the probability function we ultimately need to maximize with MCMC. 


